{% template rule_expand_args %}
    arg(X) :- attacks(X, _).
    arg(X) :- attacks(_, X).
{% endtemplate %}

{% template list_arguments_raw data %}
{%- set sorted_data = data | clingo_list_arguments %}
[
{%- for args in sorted_data %}
    [{%- for arg in args %}'{{ arg }}'{% if not loop.last %}, {% endif %}{% endfor %}],
{% endfor %}
]
{% endtemplate %}

{% template rule_conflict_free_extensions %}
    % Generate all possible subsets of arguments
    {in(X)} :- arg(X).
    % An extension is conflict-free if it doesn't contain two arguments where one attacks the other
    :- in(X), in(Y), attacks(X,Y).
{% endtemplate %}

{% template rule_admissible_extensions %}
    {% rule_conflict_free_extensions %}
    % Defense: Z defends X against attacker Y
    defends(Z, X, Y) :- in(Z), attacks(Y, X), attacks(Z, Y).

    % Admissibility: every argument must be defended against every attacker  
    :- in(X), attacks(Y, X), not defends(_, X, Y).
{% endtemplate %}

{% template rule_complete_extensions %}
    {% rule_admissible_extensions %}
    undefended(X) :- not defends(_, X, Y), attacks(Y, X).
    in(X) :- defends(Z, X, _), in(Z), not undefended(X).
    :- arg(X), not attacks(_, X), not in(X).
{% endtemplate %}

{% template rule_preferred_extensions %}
    % Get all model IDs
    model_id(ID) :- in_arg_and_id(_, ID).

    % ID1 is dominated by ID2 if ID1 is a subset of ID2
    dominated(ID1) :-
        model_id(ID1), model_id(ID2), ID1 != ID2,
        not is_superset_of(ID1, ID2),  % ID1 doesn't have extra args
        is_superset_of(ID2, ID1).      % ID2 has extra args

    % ID1 is a superset of ID2 if ID1 has an argument that ID2 doesn't
    is_superset_of(ID1, ID2) :- 
        model_id(ID1), model_id(ID2), ID1 != ID2,
        in_arg_and_id(ARG, ID1), 
        not in_arg_and_id(ARG, ID2).
    
    % An admissible extension that is not a subset of a larger admissible extension
    preferred_model_id(ID) :- model_id(ID), not dominated(ID).

    % Force choice: pick exactly one preferred extension per answer set
    1 {selected(ID) : preferred_model_id(ID)} 1.

    % Show arguments from the selected extension
    in(ARG) :- selected(ID), in_arg_and_id(ARG, ID).
{% endtemplate %}

{% template rule_grounded_extensions %}
    out(X) :- attacks(Y, X), in(Y).
    in(X) :- arg(X), out(Y) : attacks(Y, X).
{% endtemplate %}

{% template rule_stable_extensions %}
    {% rule_conflict_free_extensions %}
    attacked_by_extension(X) :- in(Y), attacks(Y, X).
    :- arg(X), not in(X), not attacked_by_extension(X).
{% endtemplate %}

{% template head %}
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ArgBlaze Report</title>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
        <!-- Prism.js CSS for code snippet with line numbers-->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
        <style>
            body{margin:0;padding:10px 20px 0 20px;font-family:'JetBrains Mono',monospace;background:#fff;color:#333;height:100vh;box-sizing:border-box;display:flex;flex-direction:column}
            body::after{content:'';height:10px;flex-shrink:0}
            /* Prism fix */
            .token.operator{background:transparent!important}
            /* Common boxed sections */
            .exhibit-section,.extensions-section{padding:0;background:#f8f9fa;border:1px solid #e0e0e0;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.05);display:flex;flex-direction:column;min-height:0}
            /* Resize handles */
            .resize-handle{height:10px;background:transparent;cursor:row-resize;display:flex;align-items:center;justify-content:center;position:relative;z-index:1000;margin:5px 0}
            .resize-handle::before{content:'';width:80px;height:3px;background:#dee2e6;border-radius:2px;transition:all 0.2s ease}
            .resize-handle:hover::before{background:#28a745;width:120px;height:4px;box-shadow:0 2px 8px rgba(40, 167, 69, 0.3)}
            .resize-handle:active::before{background:#1e7e34}
            .section-header{display:flex;justify-content:space-between;align-items:center;padding:5px;cursor:pointer;user-select:none;border-bottom:1px solid #e0e0e0;flex-shrink:0}
            .main-content > .section-header{cursor:default;margin-bottom:0;background:#f8f9fa;border:1px solid #e0e0e0;border-radius:8px 8px 0 0;box-shadow:0 2px 4px rgba(0,0,0,.05);border-bottom:1px solid #e0e0e0}
            .section-header h3{margin:0;font-size:16px;font-weight:600;color:#333}
            .section-toggle{font-size:14px;color:#666;transition:transform 0.2s ease}
            .section-toggle.collapsed{transform:rotate(-90deg)}
            .section-content{padding:16px;overflow-y:auto;transition:max-height 0.3s ease;flex:1;min-height:0}
            .section-content.collapsed{max-height:0!important;padding-top:0;padding-bottom:0;overflow:hidden}
            .section-header:has(+ .section-content.collapsed){border-bottom:none}
            .header-controls{display:flex;align-items:center;gap:16px;flex-wrap:nowrap;min-width:0}
            .step-navigation{display:flex;align-items:center;gap:8px;flex-shrink:0}
            .nav-btn{padding:4px 8px;font-size:14px;font-weight:500;font-family:'JetBrains Mono',monospace;background:#f0f0f0;border:1px solid #d0d0d0;border-radius:4px;cursor:pointer;transition:all .2s}
            .nav-btn:hover:not(:disabled){background:#e0e0e0;border-color:#bbb}
            .nav-btn:disabled{background:#f8f8f8;border-color:#e0e0e0;color:#ccc;cursor:not-allowed}
            #step-indicator{font-size:14px;font-weight:500;color:#555;min-width:60px;text-align:center}
            .display-controls{display:flex;align-items:center;gap:8px;flex-shrink:0}
            .display-dropdown{padding:4px 8px;min-width:80px;font-size:12px;font-family:'JetBrains Mono',monospace;background:#f8f9fa;border:1px solid #d0d0d0;border-radius:4px;cursor:pointer}
            .display-dropdown:hover{background:#f0f0f0;border-color:#bbb}
            .display-dropdown:focus{outline:none;border-color:#999;box-shadow:0 0 3px rgba(0,0,0,.1)}
            /* Main content wrapper */
            .main-content{display:flex;flex-direction:column;min-height:0}
            /* Graph container */
            #graph-container{width:calc(100% - 2px);margin-left:0;margin-right:0;flex:1;border:1px solid #e0e0e0;border-top:none;border-radius:0 0 8px 8px;overflow:hidden;background:#f8f9fa;box-shadow:0 2px 4px rgba(0,0,0,.05)}
            .diagram-wrapper{display:flex;justify-content:center;align-items:center;height:100%;transform-origin: center;font-size:16px;color:#666}
            .error{color:#555;text-align:center;padding:20px}
            /* Extension list */
            .extensions-header{display:flex;justify-content:space-between;align-items:center}
            .toggle-buttons{display:flex;gap:8px;margin-left:auto}
            .toggle-btn,.extension-set{padding:4px 8px;font-size:12px;font-weight:500;font-family:'JetBrains Mono',monospace;border-radius:4px;cursor:pointer;transition:all .2s}
            .toggle-btn{background:#d0d0d0;border:1px solid #aaa}
            .toggle-btn:hover{background:#c0c0c0;border-color:#999}
            .toggle-btn.active{background:#f0f0f0;border-color:#ddd;color:#777}
            .extensions-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
            .extension-item{display:flex;align-items:flex-start;padding:6px 0;font-size:13px}
            .extension-label{font-weight:600;color:#555;min-width:100px;margin-right:8px;flex-shrink:0}
            /* Make the container for sets flexible so items wrap onto new lines */
            .extension-values{color:#555;flex:1;display:flex;flex-wrap:wrap;gap:4px}
            /* Ensure each set can wrap its own content if it gets too long */
            .extension-set{border:1px solid #d0d0d0;background:#f0f0f0;box-shadow:0 1px 2px rgba(0,0,0,.1);max-width:100%;word-break:break-word;white-space:normal}
            .extension-set:hover,.extension-set.selected{background:#FFE6CC;border-color:#D79B00;box-shadow:0 2px 4px rgba(0,0,0,.15)}
            .extension-set.selected{font-weight:600}
            /* Responsive */
            @media(max-width:600px){
                body{padding:10px 10px 0 10px}
                .header-controls{flex-direction:column;align-items:flex-start;gap:8px;width:100%}
                .step-navigation{align-self:stretch;justify-content:center}
                .display-controls{align-self:flex-end;justify-content:flex-end}
                .extensions-grid{grid-template-columns:1fr}
                #graph-container{min-height:150px}
            }
            /* Additional breakpoint for very small screens */
            @media(max-width:480px){
                .nav-btn{padding:2px 6px;font-size:12px}
                .display-dropdown{min-width:70px;font-size:11px}
                #step-indicator{min-width:50px;font-size:12px}
            }
        </style>
    </head>
{% endtemplate %}

{% template script_funcs %}
    // Initialize resize handle visibility based on section visibility
    function updateResizeHandleVisibility(){
        const handle1 = document.getElementById('resize-handle-1');
        const handle2 = document.getElementById('resize-handle-2');
        const exhibitSection = document.getElementById('exhibit-section');
        const extensionsSection = document.getElementById('extensions-section');
        
        if (handle1 && exhibitSection) {
            // Hide handle1 if exhibit section is hidden (check both computed style and inline style)
            const exhibitStyle = window.getComputedStyle(exhibitSection);
            const exhibitHidden = exhibitStyle.display === 'none';
            handle1.style.display = exhibitHidden ? 'none' : 'flex';
        }
    }

    // Calculate the scale that fits element in container
    function getFitScale(container, elem) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        const elemWidth = elem.clientWidth;
        const elemHeight = elem.clientHeight;

        return Math.min(
            containerWidth / elemWidth,
            containerHeight / elemHeight
        );
    }

    // Initialize step data
    function initializeSteps() {
        // Collect all actual step numbers from the data
        const stepSet = new Set();
        if (argumentationData.arguments) {
            argumentationData.arguments.forEach(arg => {
                const argData = Object.values(arg)[0];
                const stepItem = argData.find(item => item.step !== undefined);
                stepSet.add(stepItem.step);
            });
        }
        
        // Convert to sorted array of actual steps
        actualSteps = Array.from(stepSet).sort((a, b) => a - b);
        maxStepIndex = actualSteps.length - 1;
        
        // Keep track of the actual step value to preserve state
        const stored = sessionStorage.getItem('sessionCurrentStepValue') ?? 'End';
        let preservedStepValue = stored === 'End' ? 'End' : parseInt(stored, 10);
        
        if (preservedStepValue === 'End' || preservedStepValue == null) {
            currentStepIndex = maxStepIndex + 1;
        } else {
            currentStepIndex = actualSteps.indexOf(preservedStepValue);
        }
        
        updateStepIndicator();
        updateResizeHandleVisibility();
    }

    // Get filtered arguments for current step
    function getFilteredArguments(stepIndex) {
        if (!argumentationData.arguments) return [];
        
        // If stepIndex is beyond available steps, show all arguments
        if (stepIndex > maxStepIndex) {
            return argumentationData.arguments;
        }
        
        // Get the actual step value for this index
        const currentActualStep = actualSteps[stepIndex];
        
        return argumentationData.arguments.filter(arg => {
            const argData = Object.values(arg)[0];
            const stepItem = argData.find(item => item.step !== undefined);
            const argStep = stepItem.step;
            return argStep <= currentActualStep;
        });
    }
    
    // Get newly added arguments for a specific step
    function getNewArgumentsForStep(stepIndex) {
        if (!argumentationData.arguments) return [];
        
        // If stepIndex is beyond available steps, return empty
        if (stepIndex > maxStepIndex) {
            return [];
        }
        
        // Get the actual step value for this index
        const currentActualStep = actualSteps[stepIndex];
        
        return argumentationData.arguments.filter(arg => {
            const argData = Object.values(arg)[0];
            const stepItem = argData.find(item => item.step !== undefined);
            const argStep = stepItem.step;
            return argStep === currentActualStep;
        });
    }
    
    // Get filtered attacks for current step
    function getFilteredAttacks(stepIndex) {
        if (!argumentationData.attacks) return [];
        
        // Get argument IDs that should be visible in current step
        const visibleArgIds = new Set();
        getFilteredArguments(stepIndex).forEach(arg => {
            visibleArgIds.add(Object.keys(arg)[0]);
        });
        
        // Filter attacks to only show those between visible arguments
        return argumentationData.attacks.filter(attack => {
            return visibleArgIds.has(attack[0]) && visibleArgIds.has(attack[1]);
        });
    }

    // Filter subgraphs based on rank field for current step
    function generateSubgraphs(stepIndex) {
        // Get the selected rank direction
        const rankDirection = sessionStorage.getItem('sessionRankDirection') ?? document.getElementById('rank-direction').value;
        document.getElementById('rank-direction').value = rankDirection;
        const rankData = rankDirection === 'top' ? argumentationData.rank_top : argumentationData.rank_bottom;
        if (!rankData) return '';
        
        const filteredArguments = getFilteredArguments(stepIndex);
        const visibleArgIds = new Set(filteredArguments.map(arg => Object.keys(arg)[0]));
        
        // Group arguments by rank, only including visible ones
        const rankGroups = {};
        Object.entries(rankData).forEach(([argId, rank]) => {
            if (visibleArgIds.has(argId)) {
                if (!rankGroups[rank]) {
                    rankGroups[rank] = [];
                }
                rankGroups[rank].push(argId);
            }
        });
        
        // Sort ranks in descending order (largest rank first for top; smallest rank first for bottom)
        const sortedRanks = Object.keys(rankGroups).map(Number).sort((a, b) => {
            return rankDirection === 'top' ? b - a : a - b;
        });
        
        let subgraphString = '';
        const subgraphIds = [];
        
        sortedRanks.forEach(rank => {
            const rankLabel = rank + 1; // Convert to 1-based for display
            const subgraphId = `r${rankLabel}`;
            subgraphIds.push(subgraphId);
            subgraphString += `  subgraph ${subgraphId}[Rank ${rankLabel}]\n`;
            rankGroups[rank].forEach(argId => {
                subgraphString += `    ${argId}\n`;
            });
            subgraphString += `  end\n`;
        });
        
        // Add ghost styling for subgraphs
        if (subgraphIds.length > 0) {
            subgraphString += `  classDef ghost fill:transparent,stroke:none,color:transparent;\n`;
            subgraphString += `  class ${subgraphIds.join(',')} ghost\n`;
        }

        return subgraphString;
    }
    
    // Update step indicator and button states
    function updateStepIndicator() {
        // Save current step value to sessionStorage for preservation across updates
        if (currentStepIndex <= maxStepIndex) {
            const actualStep = actualSteps[currentStepIndex];
            sessionStorage.setItem('sessionCurrentStepValue', actualStep.toString());
        } else {
            sessionStorage.setItem('sessionCurrentStepValue', 'End');
        }
        
        if (currentStepIndex <= maxStepIndex){
            const actualStep = actualSteps[currentStepIndex];
            document.getElementById('step-indicator').textContent = `Step ${actualStep}`;
        } else {
            document.getElementById('step-indicator').textContent = `End`;
        }
        
        // Always show extensions section
        if (extensionsSection) {
            extensionsSection.style.display = 'flex';
        }
        
        document.getElementById('prev-step').disabled = currentStepIndex <= 0;
        document.getElementById('next-step').disabled = currentStepIndex > maxStepIndex;
        document.getElementById('start-step').disabled = currentStepIndex <= 0;
        document.getElementById('end-step').disabled = currentStepIndex > maxStepIndex;
        
        // Update extensions display when step changes
        updateExtensionsDisplay();
    }
    
    // Setup step navigation
    function setupStepNavigation() {
        document.getElementById('prev-step').addEventListener('click', () => {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                resetExtensionSelection();
                updateStepIndicator();
                updateGraphDisplayMode();
                updateResizeHandleVisibility();
            }
        });
        
        document.getElementById('next-step').addEventListener('click', () => {
            if (currentStepIndex <= maxStepIndex) {
                currentStepIndex++;
                resetExtensionSelection();
                updateStepIndicator();
                updateGraphDisplayMode();
                updateResizeHandleVisibility();
            }
        });

        // Quick navigation to the first step
        document.getElementById('start-step').addEventListener('click', () => {
            if (currentStepIndex > 0) {
                currentStepIndex = 0;
                resetExtensionSelection();
                updateStepIndicator();
                updateGraphDisplayMode();
                updateResizeHandleVisibility();
            }
        });
        
        // Quick navigation to the final stage
        document.getElementById('end-step').addEventListener('click', () => {
            if (currentStepIndex <= maxStepIndex) {
                currentStepIndex = maxStepIndex + 1;
                resetExtensionSelection();
                updateStepIndicator();
                updateGraphDisplayMode();
                updateResizeHandleVisibility();
            }
        });
    }

    function formatMultiLineLabel(key, argData, displayMode = 'label-summary') {
        const separator = `<hr style='border:0;border-top:1px dashed;margin:0;'/>`;
        if (displayMode === 'label' || typeof argData === 'string') {
            return `<span style='padding:4px;'>${key}</span>`;
        }

        let formattedText = `${key}<br>${separator}`;

        // Extract summary from the array structure
        const summaryItem = argData.find(item => item.summary);
        if (summaryItem && summaryItem.summary) {
            formattedText += `<span style='padding:4px;'>${summaryItem.summary}</span>`;
        }

        if (displayMode === 'label-summary-details') {
            // Extract details from the array structure
            const detailsItem = argData.find(item => item.details);
            if (detailsItem && detailsItem.details) {
                const details = detailsItem.details;
                
                let formattedDetails = ``;
                let isListFormat = false;

                if (typeof details === 'string') {
                    formattedDetails = details;
                } else if (Array.isArray(details)) {
                    details.forEach(item => {
                        isListFormat = true;
                        if (typeof item === 'string') {
                            formattedDetails += `<li>${item}</li>`;
                        } else if (typeof item === 'object' && item !== null) {
                            const allKeys = new Set();
                            Object.keys(item).forEach(key => allKeys.add(key));
                            
                            console.log(allKeys);
                            allKeys.forEach(key => {
                                if (item[key]) {
                                    formattedDetails += `<li><i>${key}</i>: ${item[key]}</li>`;
                                } else {
                                    formattedDetails += `<li>${key}</li>`;
                                }
                            });
                        }
                    });
                }
                if (formattedDetails) {
                    if (isListFormat) {
                        formattedText += `${separator}<ul style="margin:0; text-align:left;">${formattedDetails}</ul>`;
                    } else {
                        formattedText += `${separator}${formattedDetails}`;
                    }
                }
            }
        }
        return formattedText;
    }

    function initializePanzoom(wrapper, mermaidContainer) {
        // Create new panzoom instance with fit-to-screen scale
        panzoomInstance = Panzoom(mermaidContainer, { 
            canvas: true, 
            startScale: getFitScale(wrapper, mermaidContainer),
            minScale: 0.1,  // Minimum zoom level (10%)
            maxScale: 5.0   // Maximum zoom level (500%)
        });
        // Bind wheel event for zooming
        wrapper.addEventListener('wheel', function(event) {
            if (!event.shiftKey) return;
            panzoomInstance.zoomWithWheel(event);
        });
    }

    async function render() {

        // Zoom/pan state shared across renders
        const mermaidContainer = document.getElementById('mermaid-diagram')
        const wrapper = document.getElementById('wrapper');
        
        // Completely clear the container first
        mermaidContainer.innerHTML = '';

        let graph = `graph BT\n`;
        graph += `  classDef default fill:#D9E7D6,stroke:#8CB26F\n`
        graph += `  classDef add fill:#DAE8FC,stroke:#6C8EBF\n`
        graph += `  classDef select fill:#FFE6CC,stroke:#D79B00\n`
        
        // Add subgraphs
        graph += generateSubgraphs(currentStepIndex);
        
        // Get newly added nodes for current step (only highlight if stepIndex > 0)
        const newNodes = currentStepIndex > 0 ? getNewArgumentsForStep(currentStepIndex) : [];
        const newNodeIds = new Set(newNodes.map(arg => Object.keys(arg)[0]));
        
        nodeData.forEach(node => {
            graph += `  ${node.id}[\"${node.label}\"]\n`;
            
            // Determine node color based on state
            let defaultNodes='', addedNodes='', selectedNodes='';

            if (colors[node.id] === '#FFE6CC') {
                // Extension selected - keep the selected highlighting
                selectedNodes += selectedNodes ? `,${node.id}` : node.id;
            } else if (newNodeIds.has(node.id)) {
                // Newly added node in current step
                addedNodes += addedNodes ? `,${node.id}` : node.id;
            } else {
                // Default node color
                defaultNodes += defaultNodes ? `,${node.id}` : node.id;
            }
            
            if (defaultNodes) graph += `  class ${defaultNodes} default\n`;
            if (addedNodes) graph += `  class ${addedNodes} add\n`;
            if (selectedNodes) graph += `  class ${selectedNodes} select\n`;
        });
        // Add attack relationships - use filtered attacks for current step
        const filteredAttacks = getFilteredAttacks(currentStepIndex);
        filteredAttacks.forEach(attack => {
            graph += `    ${attack[0]} --> ${attack[1]}\n`;
        });
        try {
            const { svg } = await mermaid.render('diagram-id', graph);
            mermaidContainer.innerHTML = svg;
            
        if (!panzoomInstance) {
            initializePanzoom(wrapper, mermaidContainer);
        }
        } catch (error) {
            console.error('Error rendering mermaid diagram:', error);
        }
    }

    function setupExtensionClickHandlers() {
        let currentlySelected = null;

        document.querySelectorAll('.extension-set').forEach(setElement => {
            setElement.addEventListener('click', (event) => {
                event.preventDefault();

                if (currentlySelected === setElement) {
                    resetNodeHighlighting();
                    setElement.classList.remove('selected');
                    currentlySelected = null;
                    render(); // Re-render the graph to show the changes
                    return;
                }

                if (currentlySelected) {
                    currentlySelected.classList.remove('selected');
                }

                setElement.classList.add('selected');
                currentlySelected = setElement;

                const setData = setElement.getAttribute('data-set');
                const nodeIds = parseExtensionSet(setData);
                highlightNodes(nodeIds);
            });
        });
    }

    function parseExtensionSet(setString) {
        if (setString === '{}') return [];
        const content = setString.slice(1, -1).trim();
        return content ? content.split(',').map(id => id.trim()) : [];
    }

    function highlightNodes(nodeIds) {
        if (nodeIds.length === 0) {
            resetNodeHighlighting();
        } else {
            // Update colors object for highlighted nodes
            colors = {};
            nodeData.forEach(node => {
                colors[node.id] = nodeIds.includes(node.id) ? '#FFE6CC' : null;
            });
        }
        // Re-render the graph with updated colors
        render();
    }

    function resetNodeHighlighting() {
        // Reset all colors to null
        colors = {};
        nodeData.forEach(node => colors[node.id] = null);
    }

    function resetExtensionSelection() {
        // Reset node highlighting
        resetNodeHighlighting();
        
        // Remove selected class from all extension sets
        document.querySelectorAll('.extension-set.selected').forEach(setElement => {
            setElement.classList.remove('selected');
        });
    }

    function fetchNodeData(displayMode) {
        const filteredArguments = getFilteredArguments(currentStepIndex);
        return filteredArguments.map(arg => {
            const key = Object.keys(arg)[0];
            const argData = arg[key];
            return { 
                id: key, 
                label: formatMultiLineLabel(key, argData, displayMode) 
            };
        });
    }

    function updateGraphDisplayMode() {
        const displayMode = document.getElementById('argument-display-mode').value;
        sessionStorage.setItem('sessionDisplayMode', displayMode);
        // Update nodeData with new labels
        nodeData = fetchNodeData(displayMode);
        // Reset panzoom instance so it will be recreated with new scale
        if (panzoomInstance) {
            panzoomInstance.destroy();
            panzoomInstance = null;
        }
        render();
    }

    function setupControls() {
        // Setup display dropdown
        const displayModeSelect = document.getElementById('argument-display-mode');
        if (displayModeSelect) {
            displayModeSelect.addEventListener('change', updateGraphDisplayMode);
        }

        // Setup rank direction dropdown
        const rankDirectionSelect = document.getElementById('rank-direction');
        if (rankDirectionSelect) {
            rankDirectionSelect.addEventListener('change', () => {
                sessionStorage.setItem('sessionRankDirection', rankDirectionSelect.value);
                // Reset panzoom instance so it will be recreated with new scale
                if (panzoomInstance) {
                    panzoomInstance.destroy();
                    panzoomInstance = null;
                }
                render();
            });
        }

        // Setup toggle buttons
        const conflictFreeBtn = document.getElementById('toggle-conflict-free');
        const admissibleBtn = document.getElementById('toggle-admissible');

        if (conflictFreeBtn) {
            conflictFreeBtn.addEventListener('click', () => {
                const conflictFreeItem = document.getElementById('conflict-free-item');
                if (conflictFreeItem) {
                    conflictFreeBtn.classList.toggle('active');
                    if (conflictFreeBtn.classList.contains('active')) {
                        conflictFreeItem.style.display = 'none';
                        conflictFreeBtn.textContent = 'Show Conflict-free';
                    } else {
                        conflictFreeItem.style.display = 'flex';
                        conflictFreeBtn.textContent = 'Hide Conflict-free';
                    }
                }
            });
        }

        if (admissibleBtn) {
            admissibleBtn.addEventListener('click', () => {
                const admissibleItem = document.getElementById('admissible-item');
                if (admissibleItem) {
                    admissibleBtn.classList.toggle('active');
                    if (admissibleBtn.classList.contains('active')) {
                        admissibleItem.style.display = 'none';
                        admissibleBtn.textContent = 'Show Admissible';
                    } else {
                        admissibleItem.style.display = 'flex';
                        admissibleBtn.textContent = 'Hide Admissible';
                    }
                }
            });
        }
    }

    function initializeSectionHeight() {
        const maxSectionHeight = windowHeight / 4;
             
        const exhibitHeaderHeight = exhibitSection.querySelector('.section-header').offsetHeight;
        const extensionsHeaderHeight = extensionsSection.querySelector('.section-header').offsetHeight;
        const exhibitContentHeight = exhibitContent.scrollHeight;
        const extensionsContentHeight = extensionsContent.scrollHeight;

        const exhibitDesiredHeight = Math.min(exhibitHeaderHeight + exhibitContentHeight, maxSectionHeight);
        const extensionsDesiredHeight = Math.min(extensionsHeaderHeight + extensionsContentHeight, maxSectionHeight);
        const graphDesiredHeight = windowHeight - exhibitDesiredHeight - extensionsDesiredHeight;
        
        exhibitSection.style.flex = `0 0 ${exhibitDesiredHeight}px`;
        extensionsSection.style.flex = `0 0 ${extensionsDesiredHeight}px`;
        graphSection.style.flex = `1 1 ${graphDesiredHeight}px`;
    }

    function initializeGraph() {
        const displayMode = sessionStorage.getItem('sessionDisplayMode') ?? document.getElementById('argument-display-mode').value;
        document.getElementById('argument-display-mode').value = displayMode;
        
        // Initialize step navigation
        initializeSteps();
        setupStepNavigation();

        // Initialize Mermaid with compact configuration
        mermaid.initialize({
            startOnLoad: false,
            flowchart: {
                padding: 0.01,
                htmlLabels: true
            }
        });

        colors = {};
        nodeData = fetchNodeData(displayMode);
        nodeData.forEach(node => colors[node.id] = null);
        render();
        setupExtensionClickHandlers();
        setupControls();
    }

    // Function to toggle section collapse/expand
    function toggleSection(sectionName) {
        const content = document.getElementById(`${sectionName}-content`);
        const toggle = document.getElementById(`${sectionName}-toggle`);
        const section = document.getElementById(`${sectionName}-section`);
        
        if (content.classList.contains('collapsed')) {
            // Expand
            content.classList.remove('collapsed');
            toggle.classList.remove('collapsed');
            content.style.maxHeight = '';
            
            // Set flex to content height, but allow shrinking if needed
            if (section) {
                let totalHeight = section.querySelector('.section-header').offsetHeight + content.scrollHeight;            
                totalHeight = Math.min(totalHeight, windowHeight / 4);
                section.style.flex = `0 1 ${totalHeight}px`;
            }
        } else {
            // Collapse
            content.classList.add('collapsed');
            toggle.classList.add('collapsed');
            content.style.maxHeight = '0';
            if (section) {
                section.style.flex = '0 0 auto';
            }
        }
        
        // After the animation, recalculate graph layout
        setTimeout(() => {
            if (panzoomInstance) {
                const mermaidContainer = document.getElementById('mermaid-diagram');
                const wrapper = document.getElementById('wrapper');
                if (mermaidContainer && wrapper) {
                    panzoomInstance.destroy();
                    initializePanzoom(wrapper, mermaidContainer);
                }
            }
        }, 300);
    }
    
    // Get extensions for a given step from the provided extension data
    function getExtensionsForStep(stepIndex) {
        const effectiveStepIndex = Math.max(0, Math.min(stepIndex, maxStepIndex));
        return extensionData[effectiveStepIndex];
    }

    // Update extensions display based on current step
    function updateExtensionsDisplay() {
        const extensionsGrid = document.getElementById('extensions-grid');

        // Clear existing content
        extensionsGrid.innerHTML = '';

        // Get extensions for the current step        
        const extensions = getExtensionsForStep(currentStepIndex);

        // Create extension items
        const extensionTypes = [
            { key: 'conflict_free', label: 'Conflict-free', id: 'conflict-free-item', hidden: true },
            { key: 'admissible', label: 'Admissible', id: 'admissible-item', hidden: true },
            { key: 'complete', label: 'Complete', id: 'complete-item', hidden: false },
            { key: 'preferred', label: 'Preferred', id: 'preferred-item', hidden: false },
            { key: 'grounded', label: 'Grounded', id: 'grounded-item', hidden: false },
            { key: 'stable', label: 'Stable', id: 'stable-item', hidden: false }
        ];

        extensionTypes.forEach(type => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'extension-item';
            itemDiv.id = type.id;
            
            // Check if this extension type should be hidden based on toggle button state
            let shouldHide = type.hidden;
            if (type.key === 'conflict_free') {
                const conflictFreeBtn = document.getElementById('toggle-conflict-free');
                shouldHide = conflictFreeBtn && conflictFreeBtn.classList.contains('active');
            } else if (type.key === 'admissible') {
                const admissibleBtn = document.getElementById('toggle-admissible');
                shouldHide = admissibleBtn && admissibleBtn.classList.contains('active');
            }
            
            if (shouldHide) {
                itemDiv.style.display = 'none';
            }

            const labelSpan = document.createElement('span');
            labelSpan.className = 'extension-label';
            labelSpan.textContent = type.label + ':';

            const valuesSpan = document.createElement('span');
            valuesSpan.className = 'extension-values';

            // Format extensions as clickable sets
            const extensionSets = extensions[type.key] || [];
            
            extensionSets.forEach((ext, index) => {
                const setSpan = document.createElement('span');
                setSpan.className = 'extension-set';
                // Handle both array format and string format
                let setString;
                if (Array.isArray(ext)) {
                    setString = '{' + ext.join(', ') + '}';
                } else {
                    setString = ext.toString();
                }
                setSpan.setAttribute('data-set', setString);
                setSpan.textContent = setString;
                valuesSpan.appendChild(setSpan);
            });

            itemDiv.appendChild(labelSpan);
            itemDiv.appendChild(valuesSpan);
            extensionsGrid.appendChild(itemDiv);
        });

        // Re-setup click handlers for new extension sets
        setupExtensionClickHandlers();
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        if (panzoomInstance) {
            const mermaidContainer = document.getElementById('mermaid-diagram');
            const wrapper = document.getElementById('wrapper');
            if (mermaidContainer && wrapper) {
                // Reset panzoom to fit new window size
                panzoomInstance.destroy();
                initializePanzoom(wrapper, mermaidContainer);
            }
        }
    });

    // Setup resize handles functionality
    function setupResizeHandles() {
        let isResizing = false;
        let currentHandle = null;
        let startY = 0;
        let startExhibitHeight = 0;
        let startGraphHeight = 0;
        let startExtensionsHeight = 0;

        function startResize(e, handle) {
            isResizing = true;
            currentHandle = handle;
            startY = e.clientY;
            
            startExhibitHeight = exhibitSection.getBoundingClientRect().height;
            startGraphHeight = graphSection.getBoundingClientRect().height;
            startExtensionsHeight = extensionsSection.getBoundingClientRect().height;
            
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
            
            e.preventDefault();
        }

        function doResize(e) {
            if (!isResizing || !currentHandle) return;
            
            const deltaY = e.clientY - startY;
            
            // Get collapsed heights (header only)
            const exhibitHeader = exhibitSection.querySelector('.section-header');
            const extensionsHeader = extensionsSection.querySelector('.section-header');
            const exhibitMinHeight = exhibitHeader ? exhibitHeader.getBoundingClientRect().height : 50;
            const extensionsMinHeight = extensionsHeader ? extensionsHeader.getBoundingClientRect().height : 50;
            const graphMinHeight = 250; // Keep a reasonable minimum for graph
            
            // Threshold for auto-collapse (slightly above minimum to trigger collapse)
            const collapseThreshold = 20;
            
            if (currentHandle === handle1) {
                // Check if exhibit section is collapsed
                const exhibitCollapsed = exhibitContent && exhibitContent.classList.contains('collapsed');
                
                // Calculate target height for exhibit
                const targetExhibitHeight = startExhibitHeight + deltaY;
                
                if (!exhibitCollapsed) {
                    // Exhibit is currently expanded
                    if (targetExhibitHeight <= exhibitMinHeight + collapseThreshold) {
                        // Auto-collapse when getting close to minimum
                        toggleSection('exhibit');
                    } else {
                        // keep extensions height FIXED
                        const availableForExhibitAndGraph = windowHeight - startExtensionsHeight;
                        
                        // Calculate new exhibit height with constraints
                        const maxExhibitHeight = availableForExhibitAndGraph - graphMinHeight;
                        const newExhibitHeight = Math.max(
                            exhibitMinHeight + collapseThreshold, 
                            Math.min(maxExhibitHeight, targetExhibitHeight)
                        );
                        
                        // Graph gets whatever space is left
                        const newGraphHeight = availableForExhibitAndGraph - newExhibitHeight;
                        
                        // Apply the changes
                        exhibitSection.style.flex = `0 0 ${newExhibitHeight}px`;
                        graphSection.style.flex = `1 1 0`; // Takes remaining space
                        extensionsSection.style.flex = `0 0 ${startExtensionsHeight}px`; // FIXED
                    }
                } else {
                    // Exhibit is currently collapsed
                    if (targetExhibitHeight > exhibitMinHeight + collapseThreshold) {
                        // Auto-expand when dragging away from minimum
                        toggleSection('exhibit');
                    }
                }
                
            } else if (currentHandle === handle2) {
                // Check if extensions section is collapsed
                const extensionsCollapsed = extensionsContent && extensionsContent.classList.contains('collapsed');
                
                // Calculate target height for extensions
                const targetExtensionsHeight = startExtensionsHeight - deltaY;
                
                if (!extensionsCollapsed) {
                    // Extensions is currently expanded
                    if (targetExtensionsHeight <= extensionsMinHeight + collapseThreshold) {
                        // Auto-collapse when getting close to minimum
                        toggleSection('extensions');
                    } else {
                        // Keep exhibit height FIXED during handle2 resize
                        const availableForGraphAndExtensions = windowHeight - startExhibitHeight;
                        
                        // Calculate new extensions height with constraints
                        const maxExtensionsHeight = availableForGraphAndExtensions - graphMinHeight;
                        const newExtensionsHeight = Math.max(
                            extensionsMinHeight + collapseThreshold, 
                            Math.min(maxExtensionsHeight, targetExtensionsHeight)
                        );
                        
                        // Graph gets whatever space is left
                        const newGraphHeight = availableForGraphAndExtensions - newExtensionsHeight;
                        
                        // Apply the changes
                        exhibitSection.style.flex = `0 0 ${startExhibitHeight}px`; // FIXED
                        graphSection.style.flex = `1 1 0`; // Takes remaining space
                        extensionsSection.style.flex = `0 0 ${newExtensionsHeight}px`;
                    }
                } else {
                    // Extensions is currently collapsed
                    if (targetExtensionsHeight > extensionsMinHeight + collapseThreshold) {
                        // Auto-expand when dragging away from minimum
                        toggleSection('extensions');
                    }
                }
            }
            
            // Trigger graph re-render if panzoom exists
            setTimeout(() => {
                if (panzoomInstance) {
                    const mermaidContainer = document.getElementById('mermaid-diagram');
                    const wrapper = document.getElementById('wrapper');
                    if (mermaidContainer && wrapper) {
                        panzoomInstance.destroy();
                        initializePanzoom(wrapper, mermaidContainer);
                    }
                }
            }, 50);
        }

        function stopResize() {
            if (!isResizing) return;
            
            isResizing = false;
            currentHandle = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }

        // Add event listeners
        handle1.addEventListener('mousedown', (e) => startResize(e, handle1));
        handle2.addEventListener('mousedown', (e) => startResize(e, handle2));
        
        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);
        
        // Prevent text selection during resize
        document.addEventListener('selectstart', (e) => {
            if (isResizing) e.preventDefault();
        });
    }

    const windowHeight = document.body.getBoundingClientRect().height - 50;
    const handle1 = document.getElementById('resize-handle-1');
    const handle2 = document.getElementById('resize-handle-2');
    const exhibitSection = document.getElementById('exhibit-section');
    const graphSection = document.getElementById('graph-section');
    const extensionsSection = document.getElementById('extensions-section');
    const exhibitContent = document.getElementById('exhibit-content');
    const extensionsContent = document.getElementById('extensions-content');

    initializeSectionHeight();    
    initializeGraph();
    setupResizeHandles();
    updateResizeHandleVisibility();
{% endtemplate %}