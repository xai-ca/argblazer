{% template rule_expand_args %}
    arg(X) :- attacks(X, _).
    arg(X) :- attacks(_, X).
{% endtemplate %}

{% template list_arguments_raw data %}
{%- set sorted_data = data | clingo_list_arguments %}
{%- for args in sorted_data %}
    <span class="extension-set" data-set="{ {%- for arg in args %}{{ arg }}{% if not loop.last %}, {% endif %}{% endfor %}}">{ {%- for arg in args %}{{ arg }}{% if not loop.last %}, {% endif %}{% endfor %}}</span>
{% endfor %}
{% endtemplate %}

{% template rule_conflict_free_extensions %}
    % Generate all possible subsets of arguments
    {in(X)} :- arg(X).
    % An extension is conflict-free if it doesn't contain two arguments where one attacks the other
    :- in(X), in(Y), attacks(X,Y).
{% endtemplate %}

{% template rule_admissible_extensions %}
    {% rule_conflict_free_extensions %}
    % Defense: Z defends X against attacker Y
    defends(Z, X, Y) :- in(Z), attacks(Y, X), attacks(Z, Y).

    % Admissibility: every argument must be defended against every attacker  
    :- in(X), attacks(Y, X), not defends(_, X, Y).
{% endtemplate %}

{% template rule_complete_extensions %}
    {% rule_admissible_extensions %}
    undefended(X) :- not defends(_, X, Y), attacks(Y, X).
    in(X) :- defends(Z, X, _), in(Z), not undefended(X).
    :- arg(X), not attacks(_, X), not in(X).
{% endtemplate %}

{% template rule_preferred_extensions %}
    % Get all model IDs
    model_id(ID) :- in_arg_and_id(_, ID).

    % ID1 is dominated by ID2 if ID1 is a subset of ID2
    dominated(ID1) :-
        model_id(ID1), model_id(ID2), ID1 != ID2,
        not is_superset_of(ID1, ID2),  % ID1 doesn't have extra args
        is_superset_of(ID2, ID1).      % ID2 has extra args

    % ID1 is a superset of ID2 if ID1 has an argument that ID2 doesn't
    is_superset_of(ID1, ID2) :- 
        model_id(ID1), model_id(ID2), ID1 != ID2,
        in_arg_and_id(ARG, ID1), 
        not in_arg_and_id(ARG, ID2).
    
    % An admissible extension that is not a subset of a larger admissible extension
    preferred_model_id(ID) :- model_id(ID), not dominated(ID).

    % Force choice: pick exactly one preferred extension per answer set
    1 {selected(ID) : preferred_model_id(ID)} 1.

    % Show arguments from the selected extension
    in(ARG) :- selected(ID), in_arg_and_id(ARG, ID).
{% endtemplate %}

{% template rule_grounded_extensions %}
    out(X) :- attacks(Y, X), in(Y).
    in(X) :- arg(X), out(Y) : attacks(Y, X).
{% endtemplate %}

{% template rule_stable_extensions %}
    {% rule_conflict_free_extensions %}
    attacked_by_extension(X) :- in(Y), attacks(Y, X).
    :- arg(X), not in(X), not attacked_by_extension(X).
{% endtemplate %}

{% template head %}
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ArgFrame Report</title>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
        <!-- Prism.js CSS for code snippet with line numbers-->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
        <style>
            body{margin:0;padding:10px 20px 0 20px;font-family:'JetBrains Mono',monospace;background:#fff;color:#333;height:100vh;box-sizing:border-box;display:flex;flex-direction:column}
            body::after{content:'';height:10px;flex-shrink:0}
            /* Prism fix */
            .token.operator{background:transparent!important}
            /* Common boxed sections */
            .exhibit-section,.extensions-section{padding:0;background:#f8f9fa;border:1px solid #e0e0e0;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.05);display:flex;flex-direction:column;flex:1;min-height:0}
            /* Resize handles */
            .resize-handle{height:10px;background:transparent;cursor:row-resize;display:flex;align-items:center;justify-content:center;position:relative;z-index:1000;margin:5px 0}
            .resize-handle::before{content:'';width:80px;height:3px;background:#dee2e6;border-radius:2px;transition:all 0.2s ease}
            .resize-handle:hover::before{background:#28a745;width:120px;height:4px;box-shadow:0 2px 8px rgba(40, 167, 69, 0.3)}
            .resize-handle:active::before{background:#1e7e34}
            .section-header{display:flex;justify-content:space-between;align-items:center;padding:5px;cursor:pointer;user-select:none;border-bottom:1px solid #e0e0e0;flex-shrink:0}
            .main-content > .section-header{cursor:default;margin-bottom:0;background:#f8f9fa;border:1px solid #e0e0e0;border-radius:8px 8px 0 0;box-shadow:0 2px 4px rgba(0,0,0,.05);border-bottom:1px solid #e0e0e0}
            .section-header h3{margin:0;font-size:16px;font-weight:600;color:#333}
            .section-toggle{font-size:14px;color:#666;transition:transform 0.2s ease}
            .section-toggle.collapsed{transform:rotate(-90deg)}
            .section-content{padding:16px;overflow-y:auto;transition:max-height 0.3s ease;max-height:400px;flex:1;min-height:0}
            .section-content.collapsed{max-height:0!important;padding-top:0;padding-bottom:0;overflow:hidden}
            .section-header:has(+ .section-content.collapsed){border-bottom:none}
            .header-controls{display:flex;align-items:center;gap:16px;flex-wrap:nowrap;min-width:0}
            .step-navigation{display:flex;align-items:center;gap:8px;flex-shrink:0}
            .nav-btn{padding:4px 8px;font-size:14px;font-weight:500;font-family:'JetBrains Mono',monospace;background:#f0f0f0;border:1px solid #d0d0d0;border-radius:4px;cursor:pointer;transition:all .2s}
            .nav-btn:hover:not(:disabled){background:#e0e0e0;border-color:#bbb}
            .nav-btn:disabled{background:#f8f8f8;border-color:#e0e0e0;color:#ccc;cursor:not-allowed}
            #step-indicator{font-size:14px;font-weight:500;color:#555;min-width:60px;text-align:center}
            .display-controls{display:flex;align-items:center;gap:8px;flex-shrink:0}
            .display-dropdown{padding:4px 8px;min-width:80px;font-size:12px;font-family:'JetBrains Mono',monospace;background:#f8f9fa;border:1px solid #d0d0d0;border-radius:4px;cursor:pointer}
            .display-dropdown:hover{background:#f0f0f0;border-color:#bbb}
            .display-dropdown:focus{outline:none;border-color:#999;box-shadow:0 0 3px rgba(0,0,0,.1)}
            /* Main content wrapper */
            .main-content{display:flex;flex-direction:column;flex:2;min-height:0}
            /* Graph container */
            #graph-container{width:calc(100% - 2px);margin-left:0;margin-right:0;flex:1;min-height:200px;border:1px solid #e0e0e0;border-top:none;border-radius:0 0 8px 8px;overflow:hidden;background:#f8f9fa;box-shadow:0 2px 4px rgba(0,0,0,.05)}
            .diagram-wrapper{display:flex;justify-content:center;align-items:center;height:100%;transform-origin: center;font-size:16px;color:#666}
            .error{color:#555;text-align:center;padding:20px}
            /* Extension list */
            .extensions-header{display:flex;justify-content:space-between;align-items:center}
            .toggle-buttons{display:flex;gap:8px;margin-left:auto}
            .toggle-btn,.extension-set{padding:4px 8px;font-size:12px;font-weight:500;font-family:'JetBrains Mono',monospace;border-radius:4px;cursor:pointer;transition:all .2s}
            .toggle-btn{background:#d0d0d0;border:1px solid #aaa}
            .toggle-btn:hover{background:#c0c0c0;border-color:#999}
            .toggle-btn.active{background:#f0f0f0;border-color:#ddd;color:#777}
            .extensions-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
            .extension-item{display:flex;align-items:flex-start;padding:6px 0;font-size:13px}
            .extension-label{font-weight:600;color:#555;min-width:100px;margin-right:8px;flex-shrink:0}
            /* Make the container for sets flexible so items wrap onto new lines */
            .extension-values{color:#555;flex:1;display:flex;flex-wrap:wrap;gap:4px}
            /* Ensure each set can wrap its own content if it gets too long */
            .extension-set{border:1px solid #d0d0d0;background:#f0f0f0;box-shadow:0 1px 2px rgba(0,0,0,.1);max-width:100%;word-break:break-word;white-space:normal}
            .extension-set:hover,.extension-set.selected{background:#FFE6CC;border-color:#D79B00;box-shadow:0 2px 4px rgba(0,0,0,.15)}
            .extension-set.selected{font-weight:600}
            /* Responsive */
            @media(max-width:600px){
                body{padding:10px 10px 0 10px}
                .header-controls{flex-direction:column;align-items:flex-start;gap:8px;width:100%}
                .step-navigation{align-self:stretch;justify-content:center}
                .display-controls{align-self:flex-end;justify-content:flex-end}
                .extensions-grid{grid-template-columns:1fr}
                #graph-container{min-height:150px}
            }
            /* Additional breakpoint for very small screens */
            @media(max-width:480px){
                .nav-btn{padding:2px 6px;font-size:12px}
                .display-dropdown{min-width:70px;font-size:11px}
                #step-indicator{min-width:50px;font-size:12px}
            }
        </style>
    </head>
{% endtemplate %}

{% template script_funcs %}

    // Initialize resize handle visibility
    function hideElementById(eid){
        const elem = document.getElementById(eid);
        if (elem) {
            elem.style.display = currentStep <= maxStep ? 'none' : 'flex';
        }
    }

    // Calculate the scale that fits element in container
    function getFitScale(container, elem) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        const elemWidth = elem.clientWidth;
        const elemHeight = elem.clientHeight;

        return Math.min(
            containerWidth / elemWidth,
            containerHeight / elemHeight
        );
    }

    // Initialize step data
    function initializeSteps() {
        if (argumentationData.arguments) {
            // Find maximum step number
            maxStep = Math.max(...argumentationData.arguments.map(arg => {
                const argData = Object.values(arg)[0];
                // Look for step field in the array
                const stepItem = argData.find(item => item.step !== undefined);
                return stepItem ? stepItem.step : 1;
            }));
        }
        // Set currentStep to show "End" by default (maxStep + 1)
        currentStep = maxStep + 1;
        updateStepIndicator();
        hideElementById('resize-handle-2');
    }

    // Get filtered arguments for current step
    function getFilteredArguments(step) {
        if (!argumentationData.arguments) return [];
        return argumentationData.arguments.filter(arg => {
            const argData = Object.values(arg)[0];
            // Look for step field in the array
            const stepItem = argData.find(item => item.step !== undefined);
            const argStep = stepItem ? stepItem.step : 1;
            return argStep <= step;
        });
    }
    
    // Get newly added arguments for a specific step
    function getNewArgumentsForStep(step) {
        if (!argumentationData.arguments) return [];
        return argumentationData.arguments.filter(arg => {
            const argData = Object.values(arg)[0];
            // Look for step field in the array
            const stepItem = argData.find(item => item.step !== undefined);
            const argStep = stepItem ? stepItem.step : 1;
            return argStep === step;
        });
    }
    
    // Get filtered attacks for current step
    function getFilteredAttacks(step) {
        if (!argumentationData.attacks) return [];
        
        // Get argument IDs that should be visible in current step
        const visibleArgIds = new Set();
        getFilteredArguments(step).forEach(arg => {
            visibleArgIds.add(Object.keys(arg)[0]);
        });
        
        // Filter attacks to only show those between visible arguments
        return argumentationData.attacks.filter(attack => {
            return visibleArgIds.has(attack[0]) && visibleArgIds.has(attack[1]);
        });
    }

    // Filter subgraphs based on rank field for current step
    function generateSubgraphs(step) {
        if (!argumentationData.rank) return '';
        
        const filteredArguments = getFilteredArguments(step);
        const visibleArgIds = new Set(filteredArguments.map(arg => Object.keys(arg)[0]));
        
        // Group arguments by rank, only including visible ones
        const rankGroups = {};
        Object.entries(argumentationData.rank).forEach(([argId, rank]) => {
            if (visibleArgIds.has(argId)) {
                if (!rankGroups[rank]) {
                    rankGroups[rank] = [];
                }
                rankGroups[rank].push(argId);
            }
        });
        
        // Sort ranks in descending order (largest rank first)
        const sortedRanks = Object.keys(rankGroups).map(Number).sort((a, b) => b - a);
        
        let subgraphString = '';
        const subgraphIds = [];
        
        sortedRanks.forEach(rank => {
            const rankLabel = rank + 1; // Convert to 1-based for display
            const subgraphId = `r${rankLabel}`;
            subgraphIds.push(subgraphId);
            subgraphString += `  subgraph ${subgraphId}[Rank ${rankLabel}]\n`;
            rankGroups[rank].forEach(argId => {
                subgraphString += `    ${argId}\n`;
            });
            subgraphString += `  end\n`;
        });
        
        // Add ghost styling for subgraphs
        if (subgraphIds.length > 0) {
            subgraphString += `  classDef ghost fill:transparent,stroke:none,color:transparent;\n`;
            subgraphString += `  class ${subgraphIds.join(',')} ghost\n`;
        }
        
        return subgraphString;
    }
    
    // Update step indicator and button states
    function updateStepIndicator() {
        const extensionsSection = document.getElementById('extensions-section');
        const extensionsContent = document.getElementById('extensions-content');
        
        if (currentStep <= maxStep){
            document.getElementById('step-indicator').textContent = `Step ${currentStep}`;
            // Hide extensions section during steps by reducing its flex
            if (extensionsSection) {
                extensionsSection.style.flex = '0 0 0';
                extensionsSection.style.overflow = 'hidden';
            }
        } else {
            document.getElementById('step-indicator').textContent = `End`;
            // Show extensions section at the end by restoring its flex
            if (extensionsSection) {
                // Check if the extensions section is collapsed
                const isCollapsed = extensionsContent && extensionsContent.classList.contains('collapsed');
                if (isCollapsed) {
                    extensionsSection.style.flex = '0 0 auto';
                } else {
                    extensionsSection.style.flex = '1 1 0';
                }
                extensionsSection.style.overflow = 'auto';
            }
        }
        
        document.getElementById('prev-step').disabled = currentStep <= 1;
        document.getElementById('next-step').disabled = currentStep > maxStep;
        document.getElementById('start-step').disabled = currentStep <= 1;
        document.getElementById('end-step').disabled = currentStep > maxStep;
    }
    
    // Setup step navigation
    function setupStepNavigation() {
        document.getElementById('prev-step').addEventListener('click', () => {
            if (currentStep > 1) {
                currentStep--;
                resetExtensionSelection();
                updateStepIndicator();
                updateGraphDisplayMode();
                hideElementById('resize-handle-2');
            }
        });
        
        document.getElementById('next-step').addEventListener('click', () => {
            if (currentStep <= maxStep) {
                currentStep++;
                updateStepIndicator();
                updateGraphDisplayMode();
                hideElementById('resize-handle-2');
            }
        });

        // Quick navigation to the first step
        document.getElementById('start-step').addEventListener('click', () => {
            if (currentStep > 1) {
                currentStep = 1;
                resetExtensionSelection();
                updateStepIndicator();
                updateGraphDisplayMode();
                hideElementById('resize-handle-2');
            }
        });
        
        // Quick navigation to the final stage
        document.getElementById('end-step').addEventListener('click', () => {
            if (currentStep <= maxStep) {
                currentStep = maxStep + 1;
                updateStepIndicator();
                updateGraphDisplayMode();
                hideElementById('resize-handle-2');
            }
        });
    }

    function formatMultiLineLabel(key, argData, displayMode = 'label-summary') {
        const separator = `<hr style='border:0;border-top:1px dashed;margin:0;'/>`;
        if (displayMode === 'label' || typeof argData === 'string') {
            return `<span style='padding:4px;'>${key}</span>`;
        }

        let formattedText = `${key}<br>${separator}`;

        // Extract summary from the array structure
        const summaryItem = argData.find(item => item.summary);
        if (summaryItem && summaryItem.summary) {
            formattedText += `<span style='padding:4px;'>${summaryItem.summary}</span>`;
        }

        if (displayMode === 'label-summary-details') {
            // Extract details from the array structure
            const detailsItem = argData.find(item => item.details);
            if (detailsItem && detailsItem.details) {
                const details = detailsItem.details;
                
                let formattedDetails = ``
                const ruleItem = details.find(item => item.rule);
                if (ruleItem && ruleItem.rule) {
                    formattedDetails += `<li><i>rule</i>: ${ruleItem.rule}</li>`;
                }
                
                const evidenceItem = details.find(item => item.evidence);
                if (evidenceItem && evidenceItem.evidence) {
                    formattedDetails += `<li><i>evidence</i>: ${evidenceItem.evidence}</li>`;
                }
                
                const conclusionItem = details.find(item => item.conclusion);
                if (conclusionItem && conclusionItem.conclusion) {
                    formattedDetails += `<li><i>conclusion</i>: ${conclusionItem.conclusion}</li>`;
                }
                if (formattedDetails){
                    formattedText += `${separator}<ul style="margin:0; text-align:left;">${formattedDetails}</ul>`
                }
            }
        }
        return formattedText;
    }

    function initializePanzoom(wrapper, mermaidContainer) {
        // Create new panzoom instance with fit-to-screen scale
        panzoomInstance = Panzoom(mermaidContainer, { 
            canvas: true, 
            startScale: getFitScale(wrapper, mermaidContainer),
            minScale: 0.1,  // Minimum zoom level (10%)
            maxScale: 5.0   // Maximum zoom level (500%)
        });
        // Bind wheel event for zooming
        wrapper.addEventListener('wheel', function(event) {
            if (!event.shiftKey) return;
            panzoomInstance.zoomWithWheel(event);
        });
    }

    async function render() {

        // Zoom/pan state shared across renders
        const mermaidContainer = document.getElementById('mermaid-diagram')
        const wrapper = document.getElementById('wrapper');
        
        // Completely clear the container first
        mermaidContainer.innerHTML = '';

        let graph = `graph BT\n`;
        graph += `  classDef default fill:#D9E7D6,stroke:#8CB26F\n`
        graph += `  classDef add fill:#DAE8FC,stroke:#6C8EBF\n`
        graph += `  classDef select fill:#FFE6CC,stroke:#D79B00\n`
        
        // Add subgraphs
        graph += generateSubgraphs(currentStep);
        
        // Get newly added nodes for current step (only highlight if step > 1)
        const newNodes = currentStep > 1 ? getNewArgumentsForStep(currentStep) : [];
        const newNodeIds = new Set(newNodes.map(arg => Object.keys(arg)[0]));
        
        nodeData.forEach(node => {
            graph += `  ${node.id}[\"${node.label}\"]\n`;
            
            // Determine node color based on state
            let defaultNodes='', addedNodes='', selectedNodes='';

            if (colors[node.id] === '#FFE6CC') {
                // Extension selected - keep the selected highlighting
                selectedNodes += selectedNodes ? `,${node.id}` : node.id;
            } else if (newNodeIds.has(node.id)) {
                // Newly added node in current step
                addedNodes += addedNodes ? `,${node.id}` : node.id;
            } else {
                // Default node color
                defaultNodes += defaultNodes ? `,${node.id}` : node.id;
            }
            
            if (defaultNodes) graph += `  class ${defaultNodes} default\n`;
            if (addedNodes) graph += `  class ${addedNodes} add\n`;
            if (selectedNodes) graph += `  class ${selectedNodes} select\n`;
        });
        // Add attack relationships - use filtered attacks for current step
        const filteredAttacks = getFilteredAttacks(currentStep);
        filteredAttacks.forEach(attack => {
            graph += `    ${attack[0]} --> ${attack[1]}\n`;
        });
        try {
            const { svg } = await mermaid.render('diagram-id', graph);
            mermaidContainer.innerHTML = svg;
            
        if (!panzoomInstance) {
            initializePanzoom(wrapper, mermaidContainer);
        }
        } catch (error) {
            console.error('Error rendering mermaid diagram:', error);
        }
    }

    function setupExtensionClickHandlers() {
        let currentlySelected = null;

        document.querySelectorAll('.extension-set').forEach(setElement => {
            setElement.addEventListener('click', (event) => {
                event.preventDefault();

                if (currentlySelected === setElement) {
                    resetNodeHighlighting();
                    setElement.classList.remove('selected');
                    currentlySelected = null;
                    render(); // Re-render the graph to show the changes
                    return;
                }

                if (currentlySelected) {
                    currentlySelected.classList.remove('selected');
                }

                setElement.classList.add('selected');
                currentlySelected = setElement;

                const setData = setElement.getAttribute('data-set');
                const nodeIds = parseExtensionSet(setData);
                highlightNodes(nodeIds);
            });
        });
    }

    function parseExtensionSet(setString) {
        if (setString === '{}') return [];
        const content = setString.slice(1, -1).trim();
        return content ? content.split(',').map(id => id.trim()) : [];
    }

    function highlightNodes(nodeIds) {
        if (nodeIds.length === 0) {
            resetNodeHighlighting();
        } else {
            // Update colors object for highlighted nodes
            colors = {};
            nodeData.forEach(node => {
                colors[node.id] = nodeIds.includes(node.id) ? '#FFE6CC' : null;
            });
        }
        // Re-render the graph with updated colors
        render();
    }

    function resetNodeHighlighting() {
        // Reset all colors to null
        colors = {};
        nodeData.forEach(node => colors[node.id] = null);
    }

    function resetExtensionSelection() {
        // Reset node highlighting
        resetNodeHighlighting();
        
        // Remove selected class from all extension sets
        document.querySelectorAll('.extension-set.selected').forEach(setElement => {
            setElement.classList.remove('selected');
        });
    }

    function fetchNodeData(displayMode) {
        const filteredArguments = getFilteredArguments(currentStep);
        return filteredArguments.map(arg => {
            const key = Object.keys(arg)[0];
            const argData = arg[key];
            return { 
                id: key, 
                label: formatMultiLineLabel(key, argData, displayMode) 
            };
        });
    }

    function updateGraphDisplayMode() {
        const displayMode = document.getElementById('argument-display-mode').value;
        // Update nodeData with new labels
        nodeData = fetchNodeData(displayMode);
        // Reset panzoom instance so it will be recreated with new scale
        if (panzoomInstance) {
            panzoomInstance.destroy();
            panzoomInstance = null;
        }
        render();
    }

    function setupControls() {
        // Setup display dropdown
        const displayModeSelect = document.getElementById('argument-display-mode');
        if (displayModeSelect) {
            displayModeSelect.addEventListener('change', updateGraphDisplayMode);
        }

        // Setup toggle buttons
        const conflictFreeBtn = document.getElementById('toggle-conflict-free');
        const admissibleBtn = document.getElementById('toggle-admissible');
        const conflictFreeItem = document.getElementById('conflict-free-item');
        const admissibleItem = document.getElementById('admissible-item');

        if (conflictFreeBtn && conflictFreeItem) {
            conflictFreeBtn.addEventListener('click', () => {
                conflictFreeBtn.classList.toggle('active');
                if (conflictFreeBtn.classList.contains('active')) {
                    conflictFreeItem.style.display = 'none';
                    conflictFreeBtn.textContent = 'Show Conflict-free';
                } else {
                    conflictFreeItem.style.display = 'flex';
                    conflictFreeBtn.textContent = 'Hide Conflict-free';
                }
            });
        }

        if (admissibleBtn && admissibleItem) {
            admissibleBtn.addEventListener('click', () => {
                admissibleBtn.classList.toggle('active');
                if (admissibleBtn.classList.contains('active')) {
                    admissibleItem.style.display = 'none';
                    admissibleBtn.textContent = 'Show Admissible';
                } else {
                    admissibleItem.style.display = 'flex';
                    admissibleBtn.textContent = 'Hide Admissible';
                }
            });
        }
    }

    function initializeGraph() {
        const displayMode = document.getElementById('argument-display-mode').value;
        
        // Initialize step navigation
        initializeSteps();
        setupStepNavigation();

        // Initialize Mermaid with compact configuration
        mermaid.initialize({
            startOnLoad: false,
            flowchart: {
                padding: 0.01,
                htmlLabels: true
            }
        });

        colors = {};
        nodeData = fetchNodeData(displayMode);
        nodeData.forEach(node => colors[node.id] = null);
        render();
        setupExtensionClickHandlers();
        setupControls();
    }

    // Function to toggle section collapse/expand
    function toggleSection(sectionName) {
        const content = document.getElementById(`${sectionName}-content`);
        const toggle = document.getElementById(`${sectionName}-toggle`);
        const section = document.getElementById(`${sectionName}-section`);
        
        if (content.classList.contains('collapsed')) {
            // Expand
            content.classList.remove('collapsed');
            toggle.classList.remove('collapsed');
            // Remove inline max-height to let CSS max-height take effect for scrolling
            content.style.maxHeight = '';
            // Restore the section's flex properties
            if (section) {
                if (sectionName === 'exhibit' || sectionName === 'extensions') {
                    section.style.flex = '1 1 0';
                } else if (sectionName === 'graph') {
                    section.style.flex = '2 1 0';
                }
            }
        } else {
            // Collapse
            content.classList.add('collapsed');
            toggle.classList.add('collapsed');
            content.style.maxHeight = '0';
            // Minimize the section's flex to just show the header
            if (section) {
                section.style.flex = '0 0 auto';
            }
        }
        
        // After the animation, recalculate graph layout
        setTimeout(() => {
            if (panzoomInstance) {
                const mermaidContainer = document.getElementById('mermaid-diagram');
                const wrapper = document.getElementById('wrapper');
                if (mermaidContainer && wrapper) {
                    // Reset panzoom to fit new container size
                    panzoomInstance.destroy();
                    initializePanzoom(wrapper, mermaidContainer);
                }
            }
        }, 300); // Wait for CSS transition to complete
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
        if (panzoomInstance) {
            const mermaidContainer = document.getElementById('mermaid-diagram');
            const wrapper = document.getElementById('wrapper');
            if (mermaidContainer && wrapper) {
                // Reset panzoom to fit new window size
                panzoomInstance.destroy();
                initializePanzoom(wrapper, mermaidContainer);
            }
        }
    });

    // Setup resize handles functionality
    function setupResizeHandles() {
        const handle1 = document.getElementById('resize-handle-1');
        const handle2 = document.getElementById('resize-handle-2');
        const exhibitSection = document.getElementById('exhibit-section');
        const graphSection = document.getElementById('graph-section');
        const extensionsSection = document.getElementById('extensions-section');
        
        if (!handle1 || !handle2 || !exhibitSection || !graphSection || !extensionsSection) {
            return;
        }

        let isResizing = false;
        let currentHandle = null;
        let startY = 0;
        let startExhibitHeight = 0;
        let startGraphHeight = 0;
        let startExtensionsHeight = 0;

        function startResize(e, handle) {
            isResizing = true;
            currentHandle = handle;
            startY = e.clientY;
            
            // Get current flex-basis values or compute them
            const exhibitRect = exhibitSection.getBoundingClientRect();
            const graphRect = graphSection.getBoundingClientRect();
            const extensionsRect = extensionsSection.getBoundingClientRect();
            
            startExhibitHeight = exhibitRect.height;
            startGraphHeight = graphRect.height;
            startExtensionsHeight = extensionsRect.height;
            
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
            
            e.preventDefault();
        }

        function doResize(e) {
            if (!isResizing || !currentHandle) return;
            
            const deltaY = e.clientY - startY;
            const containerHeight = document.body.getBoundingClientRect().height - 50; // Account for padding (10px top + 10px bottom + 20px for margins + 10px reserved bottom space)
            
            // Get collapsed heights (header only)
            const exhibitHeader = exhibitSection.querySelector('.section-header');
            const extensionsHeader = extensionsSection.querySelector('.section-header');
            const exhibitMinHeight = exhibitHeader ? exhibitHeader.getBoundingClientRect().height : 50;
            const extensionsMinHeight = extensionsHeader ? extensionsHeader.getBoundingClientRect().height : 50;
            const graphMinHeight = 250; // Keep a reasonable minimum for graph
            
            // Threshold for auto-collapse (slightly above minimum to trigger collapse)
            const collapseThreshold = 20;
            
            // Get current heights for maximum calculations
            const currentExhibitHeight = exhibitSection.getBoundingClientRect().height;
            const currentExtensionsHeight = extensionsSection.getBoundingClientRect().height;
            
            if (currentHandle === handle1) {
                // Check if exhibit section is collapsed
                const exhibitContent = document.getElementById('exhibit-content');
                const exhibitCollapsed = exhibitContent && exhibitContent.classList.contains('collapsed');
                
                // Calculate target height for exhibit
                const targetExhibitHeight = startExhibitHeight + deltaY;
                
                if (!exhibitCollapsed) {
                    // Exhibit is currently expanded
                    if (targetExhibitHeight <= exhibitMinHeight + collapseThreshold) {
                        // Auto-collapse when getting close to minimum
                        toggleSection('exhibit');
                    } else {
                        // Calculate maximum height for exhibit: total window size - current extensions height - minimum graph size
                        const exhibitMaxHeight = containerHeight - currentExtensionsHeight - graphMinHeight;
                        
                        // Normal resize with maximum constraint
                        const newExhibitHeight = Math.max(
                            exhibitMinHeight + collapseThreshold, 
                            Math.min(exhibitMaxHeight, targetExhibitHeight)
                        );
                        const newGraphHeight = Math.max(graphMinHeight, startGraphHeight - deltaY);
                        
                        const exhibitFlex = newExhibitHeight / containerHeight * 4;
                        const graphFlex = newGraphHeight / containerHeight * 4;
                        
                        exhibitSection.style.flex = `${exhibitFlex} 1 0`;
                        graphSection.style.flex = `${graphFlex} 1 0`;
                    }
                } else {
                    // Exhibit is currently collapsed
                    if (targetExhibitHeight > exhibitMinHeight + collapseThreshold) {
                        // Auto-expand when dragging away from minimum
                        toggleSection('exhibit');
                    }
                }
                
            } else if (currentHandle === handle2) {
                // Check if extensions section is collapsed
                const extensionsContent = document.getElementById('extensions-content');
                const extensionsCollapsed = extensionsContent && extensionsContent.classList.contains('collapsed');
                
                // Calculate target height for extensions
                const targetExtensionsHeight = startExtensionsHeight - deltaY;
                
                if (!extensionsCollapsed) {
                    // Extensions is currently expanded
                    if (targetExtensionsHeight <= extensionsMinHeight + collapseThreshold) {
                        // Auto-collapse when getting close to minimum
                        toggleSection('extensions');
                    } else {
                        // Calculate maximum height for extensions: total window size - current exhibit height - minimum graph size
                        const extensionsMaxHeight = containerHeight - currentExhibitHeight - graphMinHeight;
                        
                        // Normal resize with maximum constraint
                        const newExtensionsHeight = Math.max(
                            extensionsMinHeight + collapseThreshold, 
                            Math.min(extensionsMaxHeight, targetExtensionsHeight)
                        );
                        const newGraphHeight = Math.max(graphMinHeight, startGraphHeight + deltaY);
                        
                        const graphFlex = newGraphHeight / containerHeight * 4;
                        const extensionsFlex = newExtensionsHeight / containerHeight * 4;
                        
                        graphSection.style.flex = `${graphFlex} 1 0`;
                        extensionsSection.style.flex = `${extensionsFlex} 1 0`;
                    }
                } else {
                    // Extensions is currently collapsed
                    if (targetExtensionsHeight > extensionsMinHeight + collapseThreshold) {
                        // Auto-expand when dragging away from minimum
                        toggleSection('extensions');
                    }
                }
            }
            
            // Trigger graph re-render if panzoom exists
            setTimeout(() => {
                if (panzoomInstance) {
                    const mermaidContainer = document.getElementById('mermaid-diagram');
                    const wrapper = document.getElementById('wrapper');
                    if (mermaidContainer && wrapper) {
                        panzoomInstance.destroy();
                        initializePanzoom(wrapper, mermaidContainer);
                    }
                }
            }, 50);
        }

        function stopResize() {
            if (!isResizing) return;
            
            isResizing = false;
            currentHandle = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }

        // Add event listeners
        handle1.addEventListener('mousedown', (e) => startResize(e, handle1));
        handle2.addEventListener('mousedown', (e) => startResize(e, handle2));
        
        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);
        
        // Prevent text selection during resize
        document.addEventListener('selectstart', (e) => {
            if (isResizing) e.preventDefault();
        });
    }

    initializeGraph();
    setupResizeHandles();
{% endtemplate %}