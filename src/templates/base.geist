{% template rule_expand_args %}
    arg(X) :- attacks(X, _).
    arg(X) :- attacks(_, X).
{% endtemplate %}

{% template list_arguments_raw data %}
{%- set sorted_data = data | clingo_list_arguments %}
{%- for args in sorted_data %}
    <span class="extension-set" data-set="{ {%- for arg in args %}{{ arg }}{% if not loop.last %}, {% endif %}{% endfor %}}">{ {%- for arg in args %}{{ arg }}{% if not loop.last %}, {% endif %}{% endfor %}}</span>
{% endfor %}
{% endtemplate %}

{% template list_arguments data %}
{%- set sorted_data = data | clingo_list_arguments %}
{%- for args in sorted_data %}
    $\\{ {%- for arg in args %}{{ arg }}{% if not loop.last %}, {% endif %}{% endfor %}$\\}
{% endfor %}
{% endtemplate %}

{% template rule_conflict_free_extensions %}
    % Generate all possible subsets of arguments
    {in(X)} :- arg(X).
    % An extension is conflict-free if it doesn't contain two arguments where one attacks the other
    :- in(X), in(Y), attacks(X,Y).
{% endtemplate %}

{% template rule_admissible_extensions %}
    {% rule_conflict_free_extensions %}
    % Defense: Z defends X against attacker Y
    defends(Z, X, Y) :- in(Z), attacks(Y, X), attacks(Z, Y).

    % Admissibility: every argument must be defended against every attacker  
    :- in(X), attacks(Y, X), not defends(_, X, Y).
{% endtemplate %}

{% template rule_complete_extensions %}
    {% rule_admissible_extensions %}
    undefended(X) :- not defends(_, X, Y), attacks(Y, X).
    in(X) :- defends(Z, X, _), in(Z), not undefended(X).
    :- arg(X), not attacks(_, X), not in(X).
{% endtemplate %}

{% template rule_preferred_extensions %}
    % Get all model IDs
    model_id(ID) :- in_arg_and_id(_, ID).

    % ID1 is dominated by ID2 if ID1 is a subset of ID2
    dominated(ID1) :-
        model_id(ID1), model_id(ID2), ID1 != ID2,
        not is_superset_of(ID1, ID2),  % ID1 doesn't have extra args
        is_superset_of(ID2, ID1).      % ID2 has extra args

    % ID1 is a superset of ID2 if ID1 has an argument that ID2 doesn't
    is_superset_of(ID1, ID2) :- 
        model_id(ID1), model_id(ID2), ID1 != ID2,
        in_arg_and_id(ARG, ID1), 
        not in_arg_and_id(ARG, ID2).
    
    % An admissible extension that is not a subset of a larger admissible extension
    preferred_model_id(ID) :- model_id(ID), not dominated(ID).

    % Force choice: pick exactly one preferred extension per answer set
    1 {selected(ID) : preferred_model_id(ID)} 1.

    % Show arguments from the selected extension
    in(ARG) :- selected(ID), in_arg_and_id(ARG, ID).
{% endtemplate %}

{% template rule_grounded_extensions %}
    out(X) :- attacks(Y, X), in(Y).
    in(X) :- arg(X), out(Y) : attacks(Y, X).
{% endtemplate %}

{% template rule_stable_extensions %}
    {% rule_conflict_free_extensions %}
    attacked_by_extension(X) :- in(Y), attacks(Y, X).
    :- arg(X), not in(X), not attacked_by_extension(X).
{% endtemplate %}

{% template head %}
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ArgFrame Report</title>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
        <!-- Prism.js CSS for code snippet with line numbers-->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
        <style>
            body{margin:0;padding:20px;font-family:'JetBrains Mono',monospace;background:#fff;color:#333}
            /* Prism fix */
            .token.operator{background:transparent!important}
            /* Common boxed sections */
            .exhibit-section,.extensions-section{margin-bottom:20px;padding:0;background:#f8f9fa;border:1px solid #e0e0e0;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.05)}
            .section-header{display:flex;justify-content:space-between;align-items:center;padding:16px;cursor:pointer;user-select:none;border-bottom:1px solid #e0e0e0}
            .section-header:hover{background:#f0f0f0}
            .section-header h3{margin:0;font-size:16px;font-weight:600;color:#333}
            .section-toggle{font-size:14px;color:#666;transition:transform 0.2s ease}
            .section-toggle.collapsed{transform:rotate(-90deg)}
            .section-content{padding:16px;overflow:hidden;transition:max-height 0.3s ease;max-height:none}
            .section-content.collapsed{max-height:0!important;padding-top:0;padding-bottom:0}
            /* Header */
            .af-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
            .title{font-size:18px;font-weight:600;margin:0}
            .header-controls{display:flex;align-items:center;gap:16px}
            .step-navigation{display:flex;align-items:center;gap:8px}
            .nav-btn{padding:4px 8px;font-size:14px;font-weight:500;font-family:'JetBrains Mono',monospace;background:#f0f0f0;border:1px solid #d0d0d0;border-radius:4px;cursor:pointer;transition:all .2s}
            .nav-btn:hover:not(:disabled){background:#e0e0e0;border-color:#bbb}
            .nav-btn:disabled{background:#f8f8f8;border-color:#e0e0e0;color:#ccc;cursor:not-allowed}
            #step-indicator{font-size:14px;font-weight:500;color:#555;min-width:60px;text-align:center}
            .display-controls{display:flex;align-items:center;gap:8px}
            .display-dropdown{padding:4px 8px;min-width:140px;font-size:12px;font-family:'JetBrains Mono',monospace;background:#f8f9fa;border:1px solid #d0d0d0;border-radius:4px;cursor:pointer}
            .display-dropdown:hover{background:#f0f0f0;border-color:#bbb}
            .display-dropdown:focus{outline:none;border-color:#999;box-shadow:0 0 3px rgba(0,0,0,.1)}
            /* Graph container */
            #graph-container{width:100%;height:calc(100vh - 280px);border:1px solid #e0e0e0;border-radius:8px;overflow:hidden;background:#f8f9fa;box-shadow:0 2px 8px rgba(0,0,0,.1)}
            .diagram-wrapper{display:flex;justify-content:center;align-items:center;height:100%;transform-origin: center;font-size:16px;color:#666}
            .error{color:#555;text-align:center;padding:20px}
            .vis-network{height:100%!important;font-family:'JetBrains Mono',monospace!important}
            /* Extension list */
            .extensions-section{margin-top:20px}
            .extensions-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
            .toggle-buttons{display:flex;gap:8px}
            .toggle-btn,.extension-set{padding:4px 8px;font-size:12px;font-weight:500;font-family:'JetBrains Mono',monospace;border-radius:4px;cursor:pointer;transition:all .2s}
            .toggle-btn{background:#d0d0d0;border:1px solid #aaa}
            .toggle-btn:hover{background:#c0c0c0;border-color:#999}
            .toggle-btn.active{background:#f0f0f0;border-color:#ddd;color:#777}
            .extensions-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
            .extension-item{display:flex;align-items:flex-start;padding:6px 0;font-size:13px}
            .extension-label{font-weight:600;color:#555;min-width:100px;margin-right:8px;flex-shrink:0}
            /* Make the container for sets flexible so items wrap onto new lines */
            .extension-values{color:#555;flex:1;display:flex;flex-wrap:wrap;gap:4px}
            /* Ensure each set can wrap its own content if it gets too long */
            .extension-set{border:1px solid #d0d0d0;background:#f0f0f0;box-shadow:0 1px 2px rgba(0,0,0,.1);max-width:100%;word-break:break-word;white-space:normal}
            .extension-set:hover,.extension-set.selected{background:#FFE6CC;border-color:#D79B00;box-shadow:0 2px 4px rgba(0,0,0,.15)}
            .extension-set.selected{font-weight:600}
            /* Responsive */
            @media(max-width:768px){
                .af-header{flex-direction:column;align-items:flex-start;gap:8px}
                .header-controls{flex-direction:column;align-items:flex-start;gap:8px;width:100%}
                .step-navigation{align-self:stretch;justify-content:center}
                .display-controls{align-self:stretch;justify-content:space-between}
                .extensions-grid{grid-template-columns:1fr}
                #graph-container{height:calc(100vh - 400px)}
            }
        </style>
    </head>
{% endtemplate %}

{% template script_funcs %}
// Calculate the scale that fits element in container
    function getFitScale(container, elem) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        const elemWidth = elem.clientWidth;
        const elemHeight = elem.clientHeight;

        return Math.min(
            containerWidth / elemWidth,
            containerHeight / elemHeight
        );
    }

    // Initialize step data
    function initializeSteps() {
        if (argumentationData.arguments) {
            // Find maximum step number
            maxStep = Math.max(...argumentationData.arguments.map(arg => {
                const argData = Object.values(arg)[0];
                // Look for step field in the array
                const stepItem = argData.find(item => item.step !== undefined);
                return stepItem ? stepItem.step : 1;
            }));
        }
        // Set currentStep to show "End" by default (maxStep + 1)
        currentStep = maxStep + 1;
        updateStepIndicator();
    }
    
    // Get filtered arguments for current step
    function getFilteredArguments(step) {
        if (!argumentationData.arguments) return [];
        return argumentationData.arguments.filter(arg => {
            const argData = Object.values(arg)[0];
            // Look for step field in the array
            const stepItem = argData.find(item => item.step !== undefined);
            const argStep = stepItem ? stepItem.step : 1;
            return argStep <= step;
        });
    }
    
    // Get newly added arguments for a specific step
    function getNewArgumentsForStep(step) {
        if (!argumentationData.arguments) return [];
        return argumentationData.arguments.filter(arg => {
            const argData = Object.values(arg)[0];
            // Look for step field in the array
            const stepItem = argData.find(item => item.step !== undefined);
            const argStep = stepItem ? stepItem.step : 1;
            return argStep === step;
        });
    }
    
    // Get filtered attacks for current step
    function getFilteredAttacks(step) {
        if (!argumentationData.attacks) return [];
        
        // Get argument IDs that should be visible in current step
        const visibleArgIds = new Set();
        getFilteredArguments(step).forEach(arg => {
            visibleArgIds.add(Object.keys(arg)[0]);
        });
        
        // Filter attacks to only show those between visible arguments
        return argumentationData.attacks.filter(attack => {
            return visibleArgIds.has(attack[0]) && visibleArgIds.has(attack[1]);
        });
    }

    // Filter subgraphs based on rank field for current step
    function generateSubgraphs(step) {
        if (!argumentationData.rank) return '';
        
        const filteredArguments = getFilteredArguments(step);
        const visibleArgIds = new Set(filteredArguments.map(arg => Object.keys(arg)[0]));
        
        // Group arguments by rank, only including visible ones
        const rankGroups = {};
        Object.entries(argumentationData.rank).forEach(([argId, rank]) => {
            if (visibleArgIds.has(argId)) {
                if (!rankGroups[rank]) {
                    rankGroups[rank] = [];
                }
                rankGroups[rank].push(argId);
            }
        });
        
        // Sort ranks in descending order (largest rank first)
        const sortedRanks = Object.keys(rankGroups).map(Number).sort((a, b) => b - a);
        
        let subgraphString = '';
        const subgraphIds = [];
        
        sortedRanks.forEach(rank => {
            const rankLabel = rank + 1; // Convert to 1-based for display
            const subgraphId = `r${rankLabel}`;
            subgraphIds.push(subgraphId);
            subgraphString += `  subgraph ${subgraphId}[Rank ${rankLabel}]\n`;
            rankGroups[rank].forEach(argId => {
                subgraphString += `    ${argId}\n`;
            });
            subgraphString += `  end\n`;
        });
        
        // Add ghost styling for subgraphs
        if (subgraphIds.length > 0) {
            subgraphString += `  classDef ghost fill:transparent,stroke:none,color:transparent;\n`;
            subgraphString += `  class ${subgraphIds.join(',')} ghost\n`;
        }
        
        return subgraphString;
    }
    
    // Update step indicator and button states
    function updateStepIndicator() {
        const extensionsSection = document.getElementById('extensions-section');
        
        if (currentStep <= maxStep){
            document.getElementById('step-indicator').textContent = `Step ${currentStep}`;
            // Hide extensions section during steps
            if (extensionsSection) {
                extensionsSection.style.display = 'none';
            }
        } else {
            document.getElementById('step-indicator').textContent = `End`;
            // Show extensions section at the end
            if (extensionsSection) {
                extensionsSection.style.display = 'block';
            }
        }
        
        document.getElementById('prev-step').disabled = currentStep <= 1;
        document.getElementById('next-step').disabled = currentStep > maxStep;
        document.getElementById('start-step').disabled = currentStep <= 1;
        document.getElementById('end-step').disabled = currentStep > maxStep;
    }
    
    // Setup step navigation
    function setupStepNavigation() {
        document.getElementById('prev-step').addEventListener('click', () => {
            if (currentStep > 1) {
                currentStep--;
                updateStepIndicator();
                updateGraphDisplayMode();
            }
        });
        
        document.getElementById('next-step').addEventListener('click', () => {
            if (currentStep <= maxStep) {
                currentStep++;
                updateStepIndicator();
                updateGraphDisplayMode();
            }
        });

        // Quick navigation to the first step
        document.getElementById('start-step').addEventListener('click', () => {
            if (currentStep > 1) {
                currentStep = 1;
                updateStepIndicator();
                updateGraphDisplayMode();
            }
        });
        
        // Quick navigation to the final stage
        document.getElementById('end-step').addEventListener('click', () => {
            if (currentStep <= maxStep) {
                currentStep = maxStep + 1;
                updateStepIndicator();
                updateGraphDisplayMode();
            }
        });
    }

    function formatMultiLineLabel(key, argData, displayMode = 'label-summary') {
        const separator = `<hr style='border:0;border-top:1px dashed;margin:0;'/>`;
        if (displayMode === 'label' || typeof argData === 'string') {
            return `<span style='padding:4px;'>${key}</span>`;
        }

        let formattedText = `${key}<br>${separator}`;

        // Extract summary from the array structure
        const summaryItem = argData.find(item => item.summary);
        if (summaryItem && summaryItem.summary) {
            formattedText += `<span style='padding:4px;'>${summaryItem.summary}</span>`;
        }

        if (displayMode === 'label-summary-details') {
            // Extract details from the array structure
            const detailsItem = argData.find(item => item.details);
            if (detailsItem && detailsItem.details) {
                const details = detailsItem.details;
                
                let formattedDetails = ``
                const ruleItem = details.find(item => item.rule);
                if (ruleItem && ruleItem.rule) {
                    formattedDetails += `<li><i>rule</i>: ${ruleItem.rule}</li>`;
                }
                
                const evidenceItem = details.find(item => item.evidence);
                if (evidenceItem && evidenceItem.evidence) {
                    formattedDetails += `<li><i>evidence</i>: ${evidenceItem.evidence}</li>`;
                }
                
                const conclusionItem = details.find(item => item.conclusion);
                if (conclusionItem && conclusionItem.conclusion) {
                    formattedDetails += `<li><i>conclusion</i>: ${conclusionItem.conclusion}</li>`;
                }
                if (formattedDetails){
                    formattedText += `${separator}<ul style="margin:0; text-align:left;">${formattedDetails}</ul>`
                }
            }
        }
        return formattedText;
    }

    function initializePanzoom(wrapper, mermaidContainer) {
        // Create new panzoom instance with fit-to-screen scale
        panzoomInstance = Panzoom(mermaidContainer, { 
            canvas: true, 
            startScale: getFitScale(wrapper, mermaidContainer) 
        });
        // Bind wheel event for zooming
        wrapper.addEventListener('wheel', function(event) {
            if (!event.shiftKey) return;
            panzoomInstance.zoomWithWheel(event);
        });
    }

    async function render() {

        // Zoom/pan state shared across renders
        const mermaidContainer = document.getElementById('mermaid-diagram')
        const wrapper = document.getElementById('wrapper');
        
        // Completely clear the container first
        mermaidContainer.innerHTML = '';

        let graph = `graph BT\n`;
        graph += `  classDef default fill:#D9E7D6,stroke:#8CB26F\n`
        graph += `  classDef add fill:#DAE8FC,stroke:#6C8EBF\n`
        graph += `  classDef select fill:#FFE6CC,stroke:#D79B00\n`
        
        // Add subgraphs
        graph += generateSubgraphs(currentStep);
        
        // Get newly added nodes for current step (only highlight if step > 1)
        const newNodes = currentStep > 1 ? getNewArgumentsForStep(currentStep) : [];
        const newNodeIds = new Set(newNodes.map(arg => Object.keys(arg)[0]));
        
        nodeData.forEach(node => {
            graph += `  ${node.id}[\"${node.label}\"]\n`;
            
            // Determine node color based on state
            let defaultNodes='', addedNodes='', selectedNodes='';

            if (colors[node.id] === '#FFE6CC') {
                // Extension selected - keep the selected highlighting
                selectedNodes += selectedNodes ? `,${node.id}` : node.id;
            } else if (newNodeIds.has(node.id)) {
                // Newly added node in current step
                addedNodes += addedNodes ? `,${node.id}` : node.id;
            } else {
                // Default node color
                defaultNodes += defaultNodes ? `,${node.id}` : node.id;
            }
            
            if (defaultNodes) graph += `  class ${defaultNodes} default\n`;
            if (addedNodes) graph += `  class ${addedNodes} add\n`;
            if (selectedNodes) graph += `  class ${selectedNodes} select\n`;
        });
        // Add attack relationships - use filtered attacks for current step
        const filteredAttacks = getFilteredAttacks(currentStep);
        filteredAttacks.forEach(attack => {
            graph += `    ${attack[0]} --> ${attack[1]}\n`;
        });
        try {
            const { svg } = await mermaid.render('diagram-id', graph);
            mermaidContainer.innerHTML = svg;
            
        if (!panzoomInstance) {
            initializePanzoom(wrapper, mermaidContainer);
        }
        } catch (error) {
            console.error('Error rendering mermaid diagram:', error);
        }
    }

    function setupExtensionClickHandlers() {
        let currentlySelected = null;

        document.querySelectorAll('.extension-set').forEach(setElement => {
            setElement.addEventListener('click', (event) => {
                event.preventDefault();

                if (currentlySelected === setElement) {
                    resetNodeHighlighting();
                    setElement.classList.remove('selected');
                    currentlySelected = null;
                    return;
                }

                if (currentlySelected) {
                    currentlySelected.classList.remove('selected');
                }

                setElement.classList.add('selected');
                currentlySelected = setElement;

                const setData = setElement.getAttribute('data-set');
                const nodeIds = parseExtensionSet(setData);
                highlightNodes(nodeIds);
            });
        });

        document.addEventListener('click', (event) => {
            if (!event.target.closest('.extension-set') && currentlySelected) {
                currentlySelected.classList.remove('selected');
                currentlySelected = null;
                resetNodeHighlighting();
            }
        });
    }

    function parseExtensionSet(setString) {
        if (setString === '{}') return [];
        const content = setString.slice(1, -1).trim();
        return content ? content.split(',').map(id => id.trim()) : [];
    }

    function highlightNodes(nodeIds) {
        if (nodeIds.length === 0) {
            resetNodeHighlighting();
            return;
        }

        // Update colors object for highlighted nodes
        colors = {};
        nodeData.forEach(node => {
            colors[node.id] = nodeIds.includes(node.id) ? '#FFE6CC' : null;
        });
        
        // Re-render the graph with updated colors
        render();
    }

    function resetNodeHighlighting() {
        // Reset all colors to null (let render function determine colors)
        colors = {};
        nodeData.forEach(node => colors[node.id] = null);
        
        // Re-render the graph
        render();
    }

    function fetchNodeData(displayMode) {
        const filteredArguments = getFilteredArguments(currentStep);
        return filteredArguments.map(arg => {
            const key = Object.keys(arg)[0];
            const argData = arg[key];
            return { 
                id: key, 
                label: formatMultiLineLabel(key, argData, displayMode) 
            };
        });
    }

    function updateGraphDisplayMode() {
        const displayMode = document.getElementById('argument-display-mode').value;
        // Update nodeData with new labels
        nodeData = fetchNodeData(displayMode);
        // Reset panzoom instance so it will be recreated with new scale
        if (panzoomInstance) {
            panzoomInstance.destroy();
            panzoomInstance = null;
        }
        render();
    }

    function setupControls() {
        // Setup display dropdown
        const displayModeSelect = document.getElementById('argument-display-mode');
        if (displayModeSelect) {
            displayModeSelect.addEventListener('change', updateGraphDisplayMode);
        }

        // Setup toggle buttons
        const conflictFreeBtn = document.getElementById('toggle-conflict-free');
        const admissibleBtn = document.getElementById('toggle-admissible');
        const conflictFreeItem = document.getElementById('conflict-free-item');
        const admissibleItem = document.getElementById('admissible-item');

        if (conflictFreeBtn && conflictFreeItem) {
            conflictFreeBtn.addEventListener('click', () => {
                conflictFreeBtn.classList.toggle('active');
                if (conflictFreeBtn.classList.contains('active')) {
                    conflictFreeItem.style.display = 'none';
                    conflictFreeBtn.textContent = 'Show Conflict-free';
                } else {
                    conflictFreeItem.style.display = 'flex';
                    conflictFreeBtn.textContent = 'Hide Conflict-free';
                }
            });
        }

        if (admissibleBtn && admissibleItem) {
            admissibleBtn.addEventListener('click', () => {
                admissibleBtn.classList.toggle('active');
                if (admissibleBtn.classList.contains('active')) {
                    admissibleItem.style.display = 'none';
                    admissibleBtn.textContent = 'Show Admissible';
                } else {
                    admissibleItem.style.display = 'flex';
                    admissibleBtn.textContent = 'Hide Admissible';
                }
            });
        }
    }

    function initializeGraph() {
        const displayMode = document.getElementById('argument-display-mode').value;
        
        // Initialize step navigation
        initializeSteps();
        setupStepNavigation();

        // Initialize Mermaid with compact configuration
        mermaid.initialize({
            startOnLoad: false,
            flowchart: {
                padding: 0.01,
                htmlLabels: true
            }
        });

        colors = {};
        nodeData = fetchNodeData(displayMode);
        nodeData.forEach(node => colors[node.id] = null);
        render();
        setupExtensionClickHandlers();
        setupControls();
    }

    // Function to toggle section collapse/expand
    function toggleSection(sectionName) {
        const content = document.getElementById(`${sectionName}-content`);
        const toggle = document.getElementById(`${sectionName}-toggle`);
        
        if (content.classList.contains('collapsed')) {
            // Expand
            content.classList.remove('collapsed');
            toggle.classList.remove('collapsed');
            // Set max-height to scrollHeight for smooth animation
            content.style.maxHeight = content.scrollHeight + 'px';
        } else {
            // Collapse
            content.classList.add('collapsed');
            toggle.classList.add('collapsed');
            content.style.maxHeight = '0';
        }
    }

    initializeGraph();
{% endtemplate %}